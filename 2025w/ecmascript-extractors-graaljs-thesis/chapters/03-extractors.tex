\cleardoubleoddpage%
\chapter{Extractors}
\label{ch:extractors-proposal}

This chapter presents the ECMAScript Extractors proposal, detailing its goals, syntax, and semantics. We begin by discussing the motivation behind the proposal in \zcref{sec:extractors-motivation}, focusing on the need for symmetric data construction and destruction. We then situate the proposal within the broader ECMAScript ecosystem in \zcref{sec:ecosystem-and-related-proposals}, highlighting its synergies with other pending proposals such as Pattern Matching, and with selected built-in data structures. Following this, we lay the groundwork for the implementation by elaborating on the core specification and semantics in \zcref{sec:extractors-core-specification-semantics}, laying out the functional requirements we will also later use in the evaluation phase. Finally, we review prior art of comparable features in other programming languages in \zcref{sec:extractors-prior-art}.

\section{Motivation\label{sec:extractors-motivation}}

There is an asymmetry between the mechanisms used to create data structures and those used to consume them. Developers have a multitude of language functionality for defining and constructing objects at their fingertips: classes with private fields, computed property names, factory functions, and more; however, the retrieval of this data is more limited. In particular there is currently no mechanism for executing user-defined logic during destructuring.

Consider the case where a point is given in the form of a plain JavaScript Object, and it should be destructured. This is possible with object destructuring.

\begin{simplecode}[js]
    const simplePoint = { x: 13, y: 37 };
    const { x, y } = simplePoint; // x === 13, y === 37
\end{simplecode}

But if points are given in the form of an opaque class where e.g.~we don't want to expose internal property names, destructuring is no longer possible.

\begin{simplecode}[js]
    const opaquePoint = new Point(13, 37);
    const { x, y } = opaquePoint; // x, y === undefined
\end{simplecode}

The \mintinline{js}|Point| class could define a view method to keep its internals opaque but still allow access in this context, which can then be used for array destructuring.

\begin{simplecode}[js]
    const opaquePoint = new Point(13, 37);
    // assume that this returns an array [x, y]
    const [x, y] = opaquePoint.components();
\end{simplecode}

But this is not as powerful because, unlike destructuring, this is not valid in all binding situations. For example, while with our plain point we could do destructuring in function parameters, this is not possible with a view method.

\begin{simplecode}[js]
    function f({ x, y }) { /* ... */ }
    function f(opaquePoint.components()) { /* ... */ } // Error!
\end{simplecode}

The closest we could get with our view method on the opaque \mintinline{js}|Point| class would either:

\begin{itemize}
    \item require polluting the function body with parameter-handling logic:
    \begin{simplecode}[js]
        function f(opaquePoint) {
            const [x, y] = opaquePoint.components();
            // ...
        }
    \end{simplecode}
    \item or, require misusing default parameters:
    \begin{simplecode}[js]
        function f(opaquePoint, [x, y] = opaquePoint.components()) {
            // ...
        }
        f(opaquePoint); // Or explicitly: f(opaquePoint, undefined);
    \end{simplecode}
    This would work by accepting a second parameter, which callers should always leave undefined. In that case the default logic will always call the function we need.
\end{itemize}

The proposal addresses this by introducing a mechanism to allow developers to define a special method on arbitrary objects, the result of which will be used for destructuring. Thus, as shown in the introduction in \zcref{lst:minimal-intro-example}, with the addition of this method we can write

\begin{simplecode}[js]
    function f(Point(x, y)) { /* ... */ }
\end{simplecode}

which is just as expressive as destructuring of plain objects, but backed by user-defined logic. With this addition, the proposal allows for:
\begin{itemize}
    \item Validation, through the ability to verify that a subject (the object being destructured) conforms to arbitrary constraints before attempting extraction.
    \item Transformation, by giving the capacity to convert complex objects (e.g., a custom class) into primitive representations (usually the constructor arguments) seamlessly during binding or assignment.
    \item Encapsulation, enabling \enquote{views} into an object's state without exposing its internal storage layout, even in contexts where a regular method call would not be syntactically valid.
\end{itemize}

% While we generally consider the primary motivation for ECMAScript Extractors to be user-defined destructuring (see e.g.~the introductory example in \zcref{lst:minimal-intro-example}), there are other use-cases which focus less on the natural symmetry between construction and destruction. One such example is ergonomic run-time type validation and user-defined type coercion\footnotemark{}, as demonstrated in \zcref{lst:runtime-type-validation-example}.   made possible because developers are free to define Extractors that do not necessarily follow this symmetry.  Simply adding a \mintinline{js}{Symbol.customMatcher} property to any object makes it an Extractor, allowing for arbitrary deconstruction logic on objects that are essentially just intermediaries for the sole purpose of being used in such patterns.

% \footnotetext{See \url{https://github.com/tc39/proposal-extractors/issues/20} (accessed December 2025) for discussion on this use-case. Note that this was first mentioned in the context of the now inactive Type Annotations proposal~\cite{tc39typeannotations}. In that context, it was part of the reasoning for that proposals avoidance of introducing runtime semantics in regards to typing.}

% \begin{listing}[htbp]
%     \caption{Demonstration of an \mintinline{js}{Integer} Extractor used for runtime validation and coercion.\label{lst:runtime-type-validation-example}}
%     \begin{minted}[escapeinside=!!, highlightlines={11, 21}]{js}
%         const Integer = {
%             [Symbol.customMatcher](value) {
%                 const num = Number(value);
%                 if (Number.isInteger(num)) {
%                     return [num];
%                 }
%                 return false;
%             }
%         };

%         export function consumeUntrustedInput(Integer(x)) { !\label{line:runtime-type-validation-example-consume-untrusted-input}!
%             // we have guarantees about x now, without having to pollute the function body
%         }

%         consumeUntrustedInput(1);
%         consumeUntrustedInput("1");
%         consumeUntrustedInput(1.1);    // TypeError
%         consumeUntrustedInput({});     // TypeError

%         // or equivalently when receiving untrusted input
%         const Integer(z) = ExternalAPI.getIntegerProbably(); !\label{line:runtime-type-validation-example-external-api-call}!
%     \end{minted}
% \end{listing}

% \section{Ecosystem \& Related Proposals\label{sec:ecosystem-and-related-proposals}}

% The Extractors proposal is part of the broader ECMAScript ecosystem, and as such is closely related to other pending proposals such as the Pattern Matching proposal and the Discard Binding proposal. We will discuss each of these in turn, in \zcref{sec:ecosystem-and-related-proposals-pattern-matching} and \zcref{sec:ecosystem-and-related-proposals-discard-binding} respectively. Finally, as part of considering this ecosystem, we will also provide examples of how the proposal could be used to improve the ergonomics of built-in data structures such as \mintinline{js}|Map| and \mintinline{js}|Set| in \zcref{sec:improved-ergonomics-for-built-ins}.

% \subsection{Pattern Matching Proposal\label{sec:ecosystem-and-related-proposals-pattern-matching}}

% The Pattern Matching proposal~\cite{tc39patternmatching} has the goal of generalizing conditional branching based on the structure and content of data. In particular, currently ECMAScript relies on the \mintinline{js}|switch| statement, which is limited to strict equality checks, or chains of \mintinline{js}|if|/\mintinline{js}|else| blocks. These can become verbose and difficult to read when handling complex data structures. The proposal introduces a \mintinline{js}|match| construct that allows developers to test values against patterns---including object shapes, array contents, logical conditions---in a concise and declarative manner.

% Consider the example of a network request handler in \zcref{lst:pattern-matching-example}, which demonstrates the ergonomics of structural matching, particularly when combined with bindings as part of the patterns.

% \begin{listing}[htbp]
%     \caption{Demonstrating the ergonomics of structural matching, showing how \mintinline{js}{match} could allow validating the shape of data (e.g., \mintinline{js}{status: 200}) combined with extraction of values into variables (as happens e.g. for the request body in the first \mintinline{js}{when}-clause).\label{lst:pattern-matching-example}}
%     \begin{minted}{js}
% match (res) {
%     when { status: 200, let body, ...let rest }: 
%         handleData(body, rest);
    
%     when { const status, destination: let url } and if (300 <= status && status < 400):
%         handleRedirect(url);
    
%     when { status: 500 } and if (!this.hasRetried): do {
%         retry(req);
%         this.hasRetried = true;
%     };
  
%     default: 
%         throwSomething();
% }
%     \end{minted}
% \end{listing}

% But the Pattern Matching proposal has especially strong ties to the Extractors proposal because it already contains some of its syntax and semantics. In particular, it would already allow for expressions as in \zcref{lst:pattern-matching-example-extractors}, where the \mintinline{js}|when| clause contains a syntactic construct very similar to the Extractor proposal's syntax, with some differences. Notably, the binding semantics need to be handled differently: the \mintinline{js}|when| clause isn't part of a binding pattern, so clarifying intent (just matching or also binding) needs to be done explicitly with \mintinline{js}|let|/\mintinline{js}|const| inside the pattern.

% \begin{listing}[htbp]
%     \caption{Augmenting \zcref{lst:pattern-matching-example} by also using the variation of Extractors introduced by the Pattern Matching proposal.\label{lst:pattern-matching-example-extractors}}
%     \begin{minted}{js}
% match (res) {
%     when Response({ const status, const body, ...const rest }): 
%         handleData(body, rest);
    
%     /* ... */
% }
%     \end{minted}
% \end{listing}

% With the Extractors proposal this would become even more powerful, allowing for nested matchers among other enhancements. In addition, the Extractors proposal may bring with it \mintinline{js}|Symbol.customMatcher|s for built-in objects, from which the Pattern Matching proposal would also benefit.

% \subsection{Discard Binding Proposal\label{sec:ecosystem-and-related-proposals-discard-binding}}

% The Discard Binding Proposal~\cite{tc39discardbinding} introduces the \mintinline{js}|void| keyword as a binding pattern to explicitly ignore values. This is particularly relevant for Extractors which often return multiple values (tuples) where only a subset is needed, see \zcref{lst:discard-binding-example}. This mirrors the \mintinline{js}|_| keyword found e.g.~in Scala and Rust.

% \begin{listing}[htbp]
%     \caption{Example of explicitly ignoring a value using the \mintinline{js}{void} keyword, as proposed by the Discard Binding proposal.\label{lst:discard-binding-example}}
%     \begin{minted}{js}
% // Without `void`
% const Point(_unused, y) = p; // Linter error: '_unused' is defined but never used

% // With `void` integration
% const Point(void, y) = p; // Explicitly ignored
%     \end{minted}
% \end{listing}

% \subsection{Improved Ergonomics for Built-ins\label{sec:improved-ergonomics-for-built-ins}}

% \paragraph{Map} In many situations, the built-in \mintinline{js}|Map| data type is a better fit to store key-value data than a plain ECMAScript Object. However, one reason they don't see more adoption is their comparatively poor ergonomics, as demonstrated in the following example:
% \begin{simplecode}[js]
% const { x, y } = { x: 1, y: 2 };
% \end{simplecode}
% But the equivalent is not possible with object destructuring:
% \begin{simplecode}[js]
% const { x, y } = new Map([['x', 1], ['y', 2]]); // Error
% \end{simplecode}

% With an Extractor, this would be easily possible, as demonstrated in \zcref{lst:map-extractor}.
% \begin{listing}[htbp]
%     \caption{Example of a custom Extractor for \mintinline{js}{Map} objects, enabling destructuring syntax similar to plain objects. The \mintinline{js}{Symbol.customMatcher} method converts the \mintinline{js}{Map} into a plain object, which can then be destructured using the standard object destructuring syntax.\label{lst:map-extractor}}
%     \begin{minted}{js}
% const MapExtractor = {
%     [Symbol.customMatcher](map) {
%         const obj = {};
%         for (const [key, value] of map) {
%             obj[typeof key === 'symbol' ? key : `${key}`] = value;
%         }
%         return [obj];
%     }
% }

% const MapExtractor({ x, y }) = new Map([['x', 1], ['y', 2]]);
%     \end{minted}
% \end{listing}

% (Note that naturally such a custom matcher function could also be defined on the \mintinline{js}|Map| prototype itself, which would make the ergonomics even better.)

% \paragraph{Set} The situation with \mintinline{js}|Set|s is very similar to that of \mintinline{js}|Map|s: Similarly, \enquote{normal} destructuring does not work, i.e.:
% \begin{simplecode}[js]
% const [a, b, c] = [1, 2, 3]
% const [x, y, z] = new Set([7, 8, 9]); // Error
% \end{simplecode}
% But an Extractor (again optionally defined on the prototype itself) could improve the situation, as shown in \zcref{lst:set-extractor}.
% \begin{listing}[htbp]
%     \caption{Example of a custom Extractor for \mintinline{js}{Set} objects, analogous to \zcref{lst:map-extractor}. The \mintinline{js}{Symbol.customMatcher} method converts the \mintinline{js}{Set} into an array, enabling array destructuring syntax.\label{lst:set-extractor}}
%     \begin{minted}{js}
% const SetExtractor = {
%     [Symbol.customMatcher](set) {
%         const arr = /* analogous to above, convert set -> array */;
%         return [arr];
%     }
% }

% const SetExtractor([ x, y, z ]) = new Set([7, 8, 9]);
%     \end{minted}
% \end{listing}

% \paragraph{RegExp} Regular expressions are a natural fit for Extractors since they are themselves a mechanism for transforming data, so a very simple relevant Extractor can be quite powerful. To demonstrate the conciseness that the new syntax allows, we chose to patch the \mintinline{js}|Symbol.customMatcher| directly onto the \mintinline{js}|RegExp| prototype in \zcref{lst:regexp-extractor}, although this is functionally not required.

% \begin{listing}[htbp]
%     \caption{Example of using Extractors with regular expressions. By defining \mintinline{js}{Symbol.customMatcher} on the \mintinline{js}{RegExp} prototype, regular expressions can be used directly in destructuring patterns, extracting matched groups from strings.\label{lst:regexp-extractor}}
%     % this is extracted into a different file since it breaks syntax highlighting in vscode
%     \input{../content/regexp-example.tex}
% \end{listing}

% This demonstrates that a strong use-case for the proposal is simply defining \mintinline{js}|Symbol.customMatcher|s for existing functionality that handles data transformation, allowing for concise and declarative usage.

% % \subsection{Runtime Type-Checking}

% % While the primary motivation for ECMAScript Extractors is generally considered to be user-defined destructuring, there are other use-cases such as declarative runtime type checking. Developers can define Extractors that do not \enquote{extract} in the traditional sense of decomposing an object, but instead only validate the subject against a type (generally the type the extractor is defined on) and then return the subject itself---a \enquote{Pass-Through Extractor}\footnote{See \url{https://github.com/tc39/proposal-extractors/issues/20} (accessed December 2025) for a recent discussion. Note that this was first mentioned in the context of the now inactive Type Annotations proposal~\cite{tc39typeannotations}, as part of the reasoning for that proposal's avoidance of introducing runtime semantics in regards to typing.}.

% % This class of Extractors could be particularly useful on API boundaries, to enforce that functions beyond one's control behave as expected, beyond merely trusting potentially inaccurate or outdated TypeScript definition files or similar.

% % \begin{simplecode}[js]
% %     // Concisely validating arguments or return values from the "outside world" 
% %     export function drawLine(Point(p1), Point(p2)) { /* ... */ }
% %     const Point(p) = SomeExternalModule.getPoint(/* ... */);
% % \end{simplecode}

\section{Core Specification \& Semantics\label{sec:extractors-core-specification-semantics}}

Given the proposals' early stage in the TC39 process, details in the specification are still subject to change. For this reason, we will outline functional requirements that need to be fulfilled for an implementation of the proposal, rather than overly focusing on formal specification details.

\paragraph{Extractor patterns} Consist of a qualified name and a parenthesized list of elements. The following is a list of functional requirements in regard to this pattern syntax:

\begin{itemize}
    \item The Extractor name may be an identifier reference (optionally specifying \mintinline{text}|this| or \mintinline{text}|super|), a qualified name (like \mintinline{text}|Foo.Bar|) and contain array accesses.
    \begin{simplecode}[js]
        const Foo = [
            {
                Bar: {
                    [Symbol.customMatcher](subject) { /* ... */ },
                },
            },
        ];
        const this.Foo[0].Bar(y) = x;
    \end{simplecode}

    \item The parenthesized list may contain everything that an array destructuring pattern may also contain (specification: \mintinline{text}|BindingElementList| and \mintinline{text}|AssignmentElementList| respectively). In particular this means that for bindings the elements must be simple identifiers, while for identifiers they may e.g.~contain object or array accesses.
    \begin{simplecode}[js]
        // Binding
        const Point(x, y) = p;
        const Point(obj.x, arr[0]) = p; // Error!
        // Assignment
        Point(x, y) = p;
        Point(obj.x, arr[0]) = p;
    \end{simplecode}
    
    Importantly, this includes other, nested Extractors.
    \begin{simplecode}[js]
        const Line(Point(x1, y1), Point(x2, y2)) = line;
    \end{simplecode}

    \item They must be integrated into the existing assignment and binding patterns such that statements such as
    \begin{simplecode}[js]
        const Foo(y) = x; // Binding
        Foo(y) = x; // Assignment
    \end{simplecode}
    are valid.

    \item They must also be valid as function parameters, as found in
    \begin{itemize}
        \item function declarations and expressions
        \begin{simplecode}[js]
            function draw(Point(x, y)) { /* ... */ }
            const f = function draw(Point(x, y)) { /* ... */ };
        \end{simplecode}
        \item arrow functions (whose parameters must be parenthesized to avoid ambiguity with function calls)
        \begin{simplecode}[js]
            const f = (Point(x, y)) => { /* ... */ };
        \end{simplecode}
        \item object methods; class constructors and setters
        \begin{simplecode}[js]
            class Shape {
                set center(Point(x, y)) { /* ... */ }
                constructor(Point(x, y)) { /* ... */ }
                draw(Point(x, y)) { /* ... */ }
            }
            const obj = { method(Point(x, y)) { ... } };
        \end{simplecode}
    \end{itemize}

    \item They must be valid in iteration statements
    \begin{simplecode}[js]
        for (const Point(x, y) of pointList) { /* ... */ }
        for await (const Point(x, y) of pointStream) { /* ... */ }

        for (const Key(k) in object) { /* ... */ }

        for (let Point(x, y) = start; /* ... */) { /* ... */ }
    \end{simplecode}

    \item They must be valid in \mintinline{js}|catch| clauses
    \begin{simplecode}[js]
        try { /* ... */ } catch (ErrorExtractor(error)) { /* ... */ }
    \end{simplecode}

    \item But they must in general not be valid outside of assignment (assignment expressions) and binding (variable declarations, function parameters, \ldots) patterns, where they would either be meaningless or invite confusion with regular function calls.
    
    \item Whereas in bindings the \mintinline{js}|x| and \mintinline{js}|y| of \mintinline{js}|const Point(x, y) = p;| must be new variable names, in assignments they may be anything that is valid on the left hand side of other assignments, including e.g.~member expressions (\mintinline{js}|Point(obj.x, this.arr[0]) = p;|);
    
    \item Extractors may appear inside destructuring patterns, but not as a rest element (last line in the following example).
    \begin{simplecode}[js]
        const [ Point(x, y) ] = listOfPoints;
        const { center: Point(x, y) } = shape;
        const [ ...Point(x, y) ] = iterable; // Error
    \end{simplecode}
\end{itemize}

\paragraph{Extractor runtime semantics} In general, Extractors behave analogously to array destructuring at runtime, both in binding and assignment contexts, where the only major difference is that Extractors need to first transform their input. This is defined in the \mintinline{js}|InvokeCustomMatcherOrThrow(matcher, subject)| Abstract Operation (see the Binding\-Initialization runtime semantics in the specification)\footnotemark{}:

\footnotetext{The proposal aligns itself to the Pattern Matching proposal in some ways that are not relevant if the Pattern Matching proposal is not also implemented. For example, \mintinline{text}|InvokeCustomMatcherOrThrow| in fact also takes a third argument, which is only relevant in a Pattern Matching context. While we implemented this to align with the specification, we leave it out here to avoid confusion.}

\begin{enumerate}
    \setcounter{enumi}{-1}
    \item (Where \mintinline{js}|matcher| is the Extractor, i.e. the \mintinline{js}|Foo| in \mintinline{js}|const Foo(y) = x;|, and \mintinline{js}|subject| the right hand side, i.e. the \mintinline{js}|x| in the previous example.)
    \item If \mintinline{js}|matcher| is not an Object, throw a \mintinline{js}|TypeError|
    \item Let \mintinline{js}|subject| be the value on the right hand side (i.e., the \mintinline{js}|x| in \mintinline{js}|const Foo(y) = x;|)
    \item Let \mintinline{js}|f| be \mintinline{js}|matcher[Symbol.customMatcher]|\footnotemark; if it is undefined throw a \mintinline{js}|TypeError|
    \item Let \mintinline{js}|result| be \mintinline{js}|f.apply(matcher, subject)|; if it is not an Object, throw a \mintinline{js}|TypeError|    
    (The \mintinline{js}|apply| method of function instances calls the respective function with the first argument as its \mintinline{js}|this| value, and passes on the remaining arguments.)

    \item Return an iterator for \mintinline{js}|result|
\end{enumerate}

\footnotetext{Note that JavaScript property accessor syntax is necessesary here; see \zcref{sec:background-javascript-details}.}

Given this description, an Extractor statement such as
\begin{simplecode}[js]
    const Foo(y, z) = x;
\end{simplecode}
may be equivalently reformulated to the array destructuring assignment
\begin{simplecode}[js]
    const [y, z] = InvokeCustomMatcherOrThrow(Foo, x);
\end{simplecode}
and further, leaving out edge case and error handling and \enquote{inlining} the call,
\begin{simplecode}[js]
    const [y, z] = Foo[Symbol.customMatcher].apply(Foo, x);
\end{simplecode}

While this reformulation as a function is convenient as a demonstration of the runtime semantics, it should be noted that it cannot cover the entire syntax space of the Extractors proposal. For example, it cannot represent Extractors in binding contexts that are not variable declarations, such as function parameters or the \mintinline{js}{catch} clause.

% \paragraph{InvokeCustomMatcherOrThrow(matcher, subject)} Abstract Operation (see the Binding\-Initialization runtime semantics in the specification)\footnote{The proposal aligns itself to the Pattern Matching proposal in some ways that are not relevant if the Pattern Matching proposal is not also implemented. For example, \mintinline{text}|InvokeCustomMatcherOrThrow| in fact also takes a third argument, which is only relevant in a Pattern Matching context. While we implemented this to align with the specification, we leave it out here and in the binding/assignment semantics description to avoid confusion.}
% \begin{enumerate}
%     \item If \mintinline{js}|matcher| is not an Object, throw a \mintinline{js}|TypeError|
%     \item Let \mintinline{js}|f| be \mintinline{js}|matcher[Symbol.customMatcher]|; if it is undefined throw a \mintinline{js}|TypeError|
%     \item Let \mintinline{js}|result| be \mintinline{js}|f.apply(matcher, subject)|; if it is not an Object, throw a \mintinline{js}|TypeError|
%     \item Return an iterator for \mintinline{js}|result|
% \end{enumerate}

% \paragraph{Extractor binding semantics} (see the BindingInitialization runtime semantics in the specification)
% \begin{enumerate}
%     \item Let \mintinline{text}|extractor| be the expression that is covered by \mintinline{text}|ExtractorMemberExpression| (i.e., the \mintinline{js}|Foo| in \mintinline{js}|const Foo(y) = x;|)
%     \item Let \mintinline{text}|iterator| be \mintinline{text}|InvokeCustomMatcherOrThrow(extractor, value)| (where value is the right hand side---\mintinline{js}|x| in the previous example)
%     \item Using this \mintinline{text}|iterator|, perform the same binding steps that would happen when handling an array binding (c.f. \mintinline{text}|IteratorBindingInitialization| in the specification)
%     \item Close the \mintinline{text}|iterator| if necessary, and return the result from the previous step
% \end{enumerate}

% \paragraph{Extractor assignment semantics} (see the DestructuringAssignmentEvaluation runtime semantics in the specification) must behave analogously to the extractor binding pattern, adjusted for the general differences between binding and assignment semantics.

% \section{Prior Art\label{sec:extractors-prior-art}}

% %The conceptual influence behind the proposal is the concept of reversible constructors\footnotemark{}, originating from functional programming, which has also been called \enquote{Extraction} in the literature~\cite{matchingobjects07}. 

% \footnotetext{See \url{https://github.com/tc39/proposal-pattern-matching/issues/63} (accessed December 2025) for a detailed elaboration.}

% The proposal itself mentions the following language features as prior art:

% \begin{itemize}
%     \item \textbf{Scala} Extractor Objects
%     \item \textbf{C\#} Deconstruct
%     \item \textbf{F\#} Active Patterns
%     \item \textbf{Rust} Enums \& Pattern Matching
% \end{itemize}

% We will briefly describe each, and compare it to the proposed ECMAScript Extractors.

% \paragraph{Scala} Perhaps the most direct example of this pattern in other languages is Scala~\cite{matchingobjects07}, where Extractor Objects are objects with an \mintinline{scala}|unapply| method (see \zcref{lst:scala-extractor-object-example}), which is effectively equivalent in purpose and behavior to the method behind \mintinline{js}|Symbol.customMatcher|. From the Scala documentation: \enquote{Whereas the \mintinline{scala}|apply| method is like a constructor which takes arguments and creates an object, the \mintinline{scala}|unapply| method takes an object and tries to give back the arguments.}\footnote{\url{https://docs.scala-lang.org/tour/extractor-objects.html}, accessed December 2025}

% \begin{listing}[htbp]
%     \caption{Example of a Scala Extractor Object, showcasing the \mintinline{scala}{unapply} method and its usage.\label{lst:scala-extractor-object-example}}
%     \begin{minted}{Scala}
% case class Point(x: Int, y: Int)

% val p = Point(10, 20) // Construction
% val Point(x, y) = p // Extraction (calls Point.unapply(p))
%     \end{minted}
% \end{listing}

% The \mintinline{scala}|unapply| method may be refutable (may not succeed), but if it returns \mintinline{Scala}|None| or throws an exception, an exception is thrown on assignment.

% \paragraph{C\#} While both Scala and the ECMAScript proposal essentially define extractors as objects with a certain (generally static) method, C\# relies on a \mintinline{csharp}|Deconstruct| instance method on the object type to be deconstructed\footnote{\url{https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct}, accessed December 2025}.

% \begin{listing}[htbp]
%     \caption{Example of a C\# class with a \mintinline{csharp}{Deconstruct} method and its usage.\label{lst:csharp-deconstruct-example}}
%     \begin{minted}[highlightlines={13-18, 24}]{csharp}
% // (C#)
% public class Person
% {
%     public string FirstName { get; set; }
%     public string LastName { get; set; }

%     public Person(string fname, string lname)
%     {
%         FirstName = fname;
%         LastName = lname;
%     }

%     public void Deconstruct(out string fname, out string lname)
%     {
%         // Arbitrary logic in here 
%         fname = FirstName;
%         lname = LastName;
%     }
% }

% // Somewhere else:
% {
%     var p = new Person("John", "Smith")
%     var (fName, lName) = p;

%     // Compile time error since no matching Deconstructor is found
%     var (fName) = p;
% }
%     \end{minted}
% \end{listing}

% But while this has some benefits, like allowing it to omit the requirement of specifying which Extractor shall be used (as is always required in e.g.~Scala), it's more limiting than the alternative: Constructs like \zcref{lst:temporal-instant-extractor-example} in ECMAScript, where an Extractor operates on multiple different types that may not have a relation with each other or may even be primitives, are not possible with the instance-method approach. In this sense the ECMAScript implementation opts for increased flexibility and power over clearly enforced Constructor-Extractor symmetry, at the cost of slightly increased verbosity.

% \begin{listing}[htbp]
%     \caption{Example of an ECMAScript Extractor that operates on multiple different types, to contrast with the C\# approach in \zcref{lst:csharp-deconstruct-example}.\label{lst:temporal-instant-extractor-example}}
%     \begin{minted}{js}
% const InstantExtractor = {
%     [Symbol.customMatcher](value) {
%         if (value instanceof Temporal.Instant) {
%             return [value];
%         } else if (value instanceof Date) {
%             return [Temporal.Instant.fromEpochMilliseconds(+value)];
%         } else if (typeof value === 'string') {
%             return [Temporal.Instant.from(value)];
%         }
%     }
% };

% // Two different classes and a primitive are all used with the same Extractor
% const InstantExtractor(x) = Temporal.Instant.from(0);
% const InstantExtractor(y) = new Date(0);
% const InstantExtractor(z) = '1970-01-01T00:00:00Z';
%     \end{minted}
% \end{listing}

% \paragraph{F\#} While Scala (at least in terms of naming) focuses on the symmetry between its \mintinline{scala}|apply| and \mintinline{scala}|unapply| methods on Extractor Objects, F\# has a very generic concept of Active Patterns, which allow developers to effectively define named \enquote{views} on arbitrary data.

% \begin{listing}[htbp]
%     \caption{Example of a refutable F\# Active Pattern with two failure branches.\label{lst:fsharp-active-pattern-example}}
%     \begin{minted}{fsharp}
% let (|Point|_|) (input: string) =
%     let parts = input.Split(',')
%     match parts with
%     | [| x; y |] -> 
%         try Some(int x, int y) 
%         with _ -> None // Parse failed
%     | _ -> None // Format failed

% let rawData = "10,20"

% match rawData with
%     | Point (x, y) -> (* ...use x and y... *)
%     | _ -> (* Error *)
%     \end{minted}
% \end{listing}
% \zcref[S]{lst:fsharp-active-pattern-non-refutable-example} represents a very close functional equivalent to the proposed ECMAScript Extractors. But it's important to note that the above Active Pattern is refutable (as can be seen by the two failure branches), and that this would cause a compilation error if used in a binding without being handled. One way around this would be to introduce default values, as demonstrated in the following. Nevertheless, this doesn't directly map to the proposed behavior in ECMAScript, which is to throw a TypeError if the extractor doesn't succeed.

% \begin{listing}[htbp]
%     \caption{Example of a non-refutable F\# Active Pattern with no failure branches, contrasting with the refutable example in \zcref{lst:fsharp-active-pattern-example}.\label{lst:fsharp-active-pattern-non-refutable-example}}
%     \begin{minted}{fsharp}
% let (|Point|) (input: string) =
%     let parts = input.Split(',')
%     match parts with
%     | [| x; y |] -> 
%         match (Int32.TryParse x, Int32.TryParse y) with
%         | ((true, ix), (true, iy)) -> (ix, iy)
%         | _ -> (0, 0) // Parse failed
%     | _ -> (0, 0) // Format failed
%     \end{minted}
% \end{listing}

% \paragraph{Rust}
% Unlike the Active Patterns of F\# or the Extractors of Scala and this ECMAScript proposal, Rust's pattern matching is primarily structural rather than programmable. In Rust, one matches against the internal layout of \mintinline{rust}|struct|s or \mintinline{rust}|enum|s. There is no implicit execution of user logic during the binding phase (destructuring).

% \begin{listing}[htbp]
%     \caption{Rust pattern matching allows destructuring of Enums and Structs, but exclusively mirrors the data layout.\label{lst:rust-enum-example}}
%     \begin{minted}{rust}
% enum Message {
%     Quit,
%     Move { x: i32, y: i32 },
%     Write(String),
% }

% let msg = Message::Move { x: 10, y: 20 };

% match msg {
%     Message::Quit => println!("Quit"),
%     Message::Move { x, y } => println!("Move to {}, {}", x, y),
%     Message::Write(text) => println!("Text: {}", text),
% }
%     \end{minted}
% \end{listing}

% # reversible constructor paradigm & prior art

% - reversible constructor paradigm seems to be the conceptual influence behind the proposal (either way it certainly appears to prioritize following it)
%     - https://github.com/tc39/proposal-pattern-matching/issues/63 (is a discussion on the pattern mathing proposal but as far as i can tell the extractors one grew out of that)
%     - the syntax to deconstruct a value should be isomorphic to the syntax used to construct it; reduces cognitive load
%     - classic example, `const p = new Point(x, y)'; `const Point(x, y) = p;' (assuming Point is set up properly)
% - precedent/prior art/historical context
%     - discourse surrounding the proposal frequently references Scala's Extractor Objects (`unapply') as precedent
%         - https://docs.scala-lang.org/tour/extractor-objects.html
%         - but Scala is statically typed so doesn't need the instanceof etc. checks that `customMatcher' of this proposals need (a rough scala vs JS code snippet would be cool)
%     - others mentioned in README (it would be great to have roughly comparable code examples for each of these)
%         - C# 8.0 Deconstruct https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct
%         - F# Active Patterns https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns
%         - Rust Enums https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html
%         - Rust Pattern Matching https://doc.rust-lang.org/book/ch19-00-patterns.html
