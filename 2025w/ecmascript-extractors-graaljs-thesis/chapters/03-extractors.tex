\cleardoubleoddpage%
\chapter{Extractors\label{sec:extractors-proposal}}

\section{Motivation}

There is an asymmetry between the mechanism used to create data structures and those used to consume them. Developers have a multitude of language functionality for object construction at their fingertips: classes with private fields, computed property names, factory functions, and more; however the retrieval of this data can often require stepping outside these declarative paradigms. While the destructuring syntax is a step towards this direction, it only allows for the extraction of data from Arrays and Objects based on their structural shapes---it doesn't support cases where transformation is required.

During development, this shortcoming may force developers to choose between encapsulation (private fields, specific constructors, \ldots) and development ergonomics (plain objects that are easy to destructure). The proposal addresses this by introducing a pattern that can execute user-defined logic during the binding phase. This logic is attached to objects through a new well-known property, \mintinline{js}{Symbol.customMatcher}, which can then be used for this purpose.

A secondary motivation, discussed in \zcref{sec:ecosystem-and-related-proposals-pattern-matching}, is to improve the ergonomics of the related \emph{Pattern Matching} proposal.

With this addition, the proposal augments the existing binding and assignment patterns to allow for:
\begin{itemize}
    \item Validation, through the ability to verify that a subject conforms to a specific type or constraint before attempting extraction.
    \item Transformation, by giving the capacity to convert complex objects (e.g., a custom Class) into primitive representations (usually the constructor arguments) seamlessly during the assignment.
    \item Encapsulation, enabling \enquote{views} into an object's state without exposing its internal storage layout.
\end{itemize}

\section{Ecosystem \& Related Proposals\label{sec:ecosystem-and-related-proposals}}

\subsection{Pattern Matching Proposal\label{sec:ecosystem-and-related-proposals-pattern-matching}}

The \emph{Pattern Matching} proposal~\cite{tc39patternmatching}, has the goal of generalizing conditional branching based on the structure and content of data. In particular, currently ECMAScript relies on the \mintinline{js}|switch| statement, which is limited to strict equality checks, or chains of \mintinline{js}|if|/\mintinline{js}|else| blocks, which can become verbose and difficult to read when handling complex data structures. It introduces a \mintinline{js}|match| construct that allows developers to test values against patterns---including object shapes, array contents, logical conditions---in a concise and declarative manner.

Consider the example of a network request handler in \zcref{lst:pattern-matching-example}, which demonstrates the ergonomics of structural matching in particular in combination with bindings as part of the patterns.

\begin{listing}[htbp]
    \begin{minted}{js}
match (res) {
    when { status: 200, let body, ...let rest }: 
        handleData(body, rest);
    
    when { const status, destination: let url } and if (300 <= status && status < 400):
        handleRedirect(url);
    
    when { status: 500 } and if (!this.hasRetried): do {
        retry(req);
        this.hasRetried = true;
    };
  
    default: 
        throwSomething();
}
    \end{minted}
    \caption{Demonstrating the ergonomics of structural matching, showing how \mintinline{js}{match} could allow validating the shape of data (e.g., \mintinline{js}{status: 200}) combined with extraction of values into variables (as happens e.g. for the request body in the first \mintinline{js}{when}-clause).\label{lst:pattern-matching-example}}
\end{listing}

But the Pattern Matching proposal has especially strong ties to the Extractors proposal because it already contains some of its syntax and semantics. In particular, it would already allow for expressions as in \zref{lst:pattern-matching-example-extractors}, which is very close to a basic use case for Extractors (with the minor change that binding semantics are described differently: in this case \mintinline{js}|let| is inside the parentheses).

\begin{listing}[htbp]
    \begin{minted}{js}
match (res) {
    when Response({ const status, const body, ...const rest }): 
        handleData(body, rest);
    
    /* ... */
}
    \end{minted}
    \caption{Augmenting \zcref{lst:pattern-matching-example} by also using the variation of Extractors introduced by the Pattern Matching proposal.\label{lst:pattern-matching-example-extractors}}
\end{listing}

With the Extractors proposal this would become even more powerful, allowing for nested matchers among other enhancements. In addition, the Extractors proposal may bring with it \mintinline{js}|Symbol.customMatcher|s for built-in objects, from which the Pattern Matching proposal would also benefit.

\subsection{Discard Binding Proposal}

The \emph{Discard Binding} Proposal~\cite{tc39discardbinding} introduces the \mintinline{js}|void| keyword as a binding pattern to explicitly ignore values. This is particularly relevant for Extractors which often return multiple values (tuples) where only a subset is needed.

\begin{simplecode}[js]
// Without `void`
const Point(_unused, y) = p; // Linter error: '_unused' is defined but never used

// With `void` integration
const Point(void, y) = p; // Explicitly ignored
\end{simplecode}

This mirrors the \mintinline{js}|_| keyword found e.g.~in Scala and Rust.

\subsection{Improved Ergonomics for Built-ins}

\paragraph{Map} In many situations, the built-in \mintinline{js}|Map| data type is a better fit to store key-value data than a plain ECMAScript Object. But one reason they don't see more adoption is their comparatively poor ergonomics, e.g.~one can do 
\begin{simplecode}[js]
const { x, y } = { x: 1, y: 2 };
\end{simplecode}
But the equivalent is not possible with object destructuring:
\begin{simplecode}[js]
const { x, y } = new Map([['x', 1], ['y', 2]]) // Error
\end{simplecode}

With an Extractor, this would be easily possible, as demonstrated in \zcref{lst:map-extractor}.
\begin{listing}[htbp]
    \begin{minted}{js}
const MapExtractor = {
    [Symbol.customMatcher](map) {
        const obj = {};
        for (const [key, value] of map) {
            obj[typeof key === 'symbol' ? key : `${key}`] = value;
        }
        return [obj];
    }
}

const MapExtractor({ x, y }) = new Map([['x', 1], ['y', 2]]);
    \end{minted}
    \caption{Example of a custom Extractor for \mintinline{js}{Map} objects, enabling destructuring syntax similar to plain objects. The \mintinline{js}{Symbol.customMatcher} method converts the \mintinline{js}{Map} into a plain object, which can then be destructured using the standard object destructuring syntax.\label{lst:map-extractor}}
\end{listing}

(Note that naturally such a custom matcher function could also be defined on the \mintinline{js}|Map| prototype itself, which would make the ergonomics even better.)

\paragraph{Set} The situation with \mintinline{js}|Set|s is very similar to that of \mintinline{js}|Map|s: Also here, \enquote{normal} destructuring does not work, i.e.:
\begin{simplecode}[js]
const [a, b, c] = [1, 2, 3]
const [x, y, z] = new Set([7, 8, 9]); // Error
\end{simplecode}
But an Extractor (again optionally defined on the prototype itself) could improve the situation, as shown in \zcref{lst:set-extractor}.
\begin{listing}[htbp]
    \begin{minted}{js}
const SetExtractor = {
    [Symbol.customMatcher](set) {
        const arr = /* analogous to above, convert set -> array */;
        return [arr];
    }
}

const SetExtractor([ x, y, z ]) = new Set([7, 8, 9]);
    \end{minted}
    \caption{Example of a custom Extractor for \mintinline{js}{Set} objects, analogous to \zcref{lst:map-extractor}. The \mintinline{js}{Symbol.customMatcher} method converts the \mintinline{js}{Set} into an array, enabling array destructuring syntax.\label{lst:set-extractor}}
\end{listing}

\paragraph{RegExp} Regular expressions are a natural fit for Extractors since they are themselves a mechanism for transforming data, so a very simple relevant Extractor can be quite powerful. To demonstrate the conciseness that the new syntax allows, we chose to patch the \mintinline{js}|Symbol.customMatcher| directly onto the \mintinline{js}|RegExp| prototype in \zcref{lst:regexp-extractor}, although this is of course functionally not required.

\begin{listing}[htbp]
% this is extracted into a different file since it breaks syntax highlighting in vscode
\input{../content/regexp-example.tex}
    \caption{Example of using Extractors with regular expressions. By defining \mintinline{js}{Symbol.customMatcher} on the \mintinline{js}{RegExp} prototype, regular expressions can be used directly in destructuring patterns, extracting matched groups from strings.\label{lst:regexp-extractor}}
\end{listing}

This demonstrates that a strong use-case for the proposal is simply defining \mintinline{js}|Symbol.customMatcher|s for existing functionality that handles data transformation, allowing for concise and declarative usage.

\subsection{Runtime Type-Checking}

While the primary motivation for ECMAScript Extractors is generally considered to be used-defined destructuring, there are other use-cases such as declarative runtime type checking. Developers can define Extractors that do not \enquote{extract} in the traditional sense of decomposing an object, but instead only validate the subject against a type (generally the type the extractor is defined on) and then return the subject itself---a \enquote{Pass-Through Extractor}\footnote{See \url{https://github.com/tc39/proposal-extractors/issues/20} (accessed 07/12/2025) for a recent discussion. Note that this was first mentioned in the context of the (now inactive) \emph{Type Annotations} proposal~\cite{tc39typeannotations} as part of the reasoning for that proposals avoidance of introducing runtime semantics in regards to typing.}.

This class of Extractors could be particularly useful on API boundaries, to enforce that functions beyond ones control behave as expected, beyond merely trusting potentially inacurrate or outdated TypeScript definition files or similar.

\begin{simplecode}[js]
    // Concisely validating arguments or return values from the "outside world" 
    export function drawLine(Point(p1), Point(p2)) { /* ... */ }
    const Point(p) = SomeExternalModule.getPoint(/* ... */);
\end{simplecode}



\section{Core Specification \& Semantics\label{sec:extractors-core-specification-semantics}}

GraalJS does not have a one-to-one implementation of the grammar in the specification, meaning that while the specification grammar defines the intended behavior, the implementation may not strictly mirror these syntactic constructions. For this reason we will outline \emph{functional requirements} that need to be fulfilled for an implementation of the proposal.

\paragraph{Extractor patterns} Consist of a qualified name (specification: \mintinline{text}|ExtractorMemberExpression|) and a parenthesized list of binding or assignment elements (specification: see \mintinline{text}|ExtractorAssignmentPattern| and \mintinline{js}|ExtractorBindingPattern| respectively).
\begin{itemize}
    \item \emph{Historical note}: Parentheses are a clear choice when symmetry with constructors is desirable, but one could also reasonably consider symmetry with array and object destructuring to be desirable. In fact, early versions of the proposal used round parentheses for \enquote{Array Extractors} (not square brackets, which would be the more immediately obvious choice, because there would be syntactic ambiguity) and curly braces for \enquote{Object Extractors}.

    Object Extractors were subsequently removed from consideration since committee members felt that reserving \mintinline{text}|identifier {| in the grammar would block too much syntax space\footnote{\url{https://github.com/tc39/proposal-extractors/issues/10}, accessed 07/12/2025}.

    \item In the simplest case, they must be made part of the existing assignment and binding patterns such that statements like
    \begin{simplecode}[js]
        const Foo(y) = x; // Binding
        Foo(y) = x; // Assignment
    \end{simplecode}
    are valid.

    \item They must also be valid as function parameters
    \begin{itemize}
        \item For function declarations and expressions
        \begin{simplecode}[js]
            function draw(Point(x, y)) { /* ... */ }
            const f = function draw(Point(x, y)) { /* ... */ };
        \end{simplecode}
        \item For arrow functions (whose parameters must be parenthesized to avoid ambiguity with function calls)
        \begin{simplecode}[js]
            const f = (Point(x, y)) => { /* ... */ };
        \end{simplecode}
        \item For class/object methods, constructors, and setters
        \begin{simplecode}[js]
            class Shape {
                set center(Point(x, y)) { /* ... */ }
                constructor(Point(x, y)) { /* ... */ }
                draw(Point(x, y)) { /* ... */ }
            }
            const obj = { method(Point(x, y)) { ... } };
        \end{simplecode}
    \end{itemize}

    \item They must be valid in iteration statements
    \begin{simplecode}[js]
        for (const Point(x, y) of pointList) { /* ... */ }
        for await (const Point(x, y) of pointStream) { /* ... */ }

        for (const Key(k) in object) { /* ... */ }

        for (let Point(x, y) = start; /* ... */) { /* ... */ }
    \end{simplecode}

    \item They must be valid in \mintinline{js}|catch| clauses
    \begin{simplecode}[js]
        try { /* ... */ } catch (ErrorExtractor(error)) { /* ... */ }
    \end{simplecode}

    \item But they must in general \emph{not} be valid outside of assignment (assignment expressions) and binding (variable declarations, function parameters, \ldots) patterns, where they would either be meaningless or invite confusion with regular function calls.
    
    \item Whereas in bindings the \mintinline{js}|x| and \mintinline{js}|y| of \mintinline{js}|const Point(x, y) = p;| must be new variable names, in assignments they may be anything that is valid on the left hand side of other assignments, including e.g.~member expressions (\mintinline{js}|Point(obj.x, this.arr[0]) = p;|);

    \item Among others (see specification for details) \mintinline{text}|ExtractorMemberExpression| may be an identifier reference (optionally specifying \mintinline{text}|this| or \mintinline{text}|super|), a qualified name (like \mintinline{text}|Foo.Bar|) and contain array accesses.
    
    \item Extractors may appear inside destructuring patterns, but not as a rest element.
    \begin{simplecode}[js]
        const [ Point(x, y) ] = listOfPoints;
        const { center: Point(x, y) } = shape;
        const [ ...Point(x, y) ] = iterable; // Error
    \end{simplecode}

    \item The parenthesized list may contain everything that an array destructuring pattern may also contain (specification: \mintinline{text}|BindingElementList| and \mintinline{text}|AssignmentElementList| respectively). Importantly this includes other, nested Extractors.
    \begin{simplecode}[js]
        const Line(Point(x1, y1), Point(x2, y2)) = line;
    \end{simplecode}
\end{itemize}

\paragraph{Extractor binding semantics} (see the BindingInitialization runtime semantics in the specification)
\begin{enumerate}
    \item Let \mintinline{text}|extractor| be the expression that is covered by  \mintinline{text}|ExtractorMemberExpression| (i.e., the \mintinline{js}|Foo| in \mintinline{js}|const Foo(y) = x;|)
    \item Let \mintinline{text}|iterator| be \mintinline{text}|InvokeCustomMatcherOrThrow(extractor, value)| (where value is the right hand side---\mintinline{js}|x| in the previous example---and \mintinline{text}|InvokeCustomMatcherOrThrow| is an Abstract Operation to be defined later)
    \item Using this \mintinline{text}|iterator|, perform the same binding steps that would happen when handling an array binding (c.f. \mintinline{text}|IteratorBindingInitialization| in the specification)
    \item Close the \mintinline{text}|iterator| if necessary, and return the result from the previous step
\end{enumerate}

\paragraph{Extractor assignment semantics} (see the DestructuringAssignmentEvaluation runtime semantics in the specification) must behave analogously to the extractor binding pattern, adjusted for the general differences between binding and assignment semantics.
    
\paragraph{InvokeCustomMatcherOrThrow(matcher, subject)} Abstract Operation (see the Binding\-Initialization runtime semantics in the specification)\footnote{The proposal aligns itself to the Pattern Matching proposal in some ways that are not relevant if the Pattern Matching proposal is not also implemented. For example, \mintinline{text}|InvokeCustomMatcherOrThrow| in fact also takes a third argument, which is only relevant in a Pattern Matching context. While we implemented this to align with the specification, we leave it out here and in the binding/assignment semantics description to avoid confusion.}
\begin{enumerate}
    \item If \mintinline{js}|matcher| is not an Object, throw a \mintinline{js}|TypeError|
    \item Let \mintinline{js}|f| be \mintinline{js}|matcher[Symbol.customMatcher]|; if it is undefined throw a \mintinline{js}|TypeError|
    \item Let \mintinline{js}|result| be \mintinline{js}|f.apply(matcher, subject)|; if it is not an Object, throw a \mintinline{js}|TypeError|
    \item Return an iterator for \mintinline{js}|result|
\end{enumerate}
