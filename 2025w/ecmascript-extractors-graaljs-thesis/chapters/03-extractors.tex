\cleardoubleoddpage%
\chapter{Extractors}
\label{ch:extractors-proposal}

As introduced in \zcref{ch:introduction}, the Extractors proposal adds a new kind of destructuring form alongside array and object destructuring. 
\begin{simplecode}[js]
    const [y] = [x];        // Array destructuring
    const { y } = { x };    // Object destructuring
    const Foo(y) = x;       // Extractors
\end{simplecode}

Any object is considered an Extractor, viable for usage in this new pattern, if it has a certain method that describes how it should be extracted. An example of such an object was given in the form of a class in \zcref{lst:minimal-intro-example}. But this example class was simplified in two important ways:

\begin{itemize}
    \item The actual proposed method name is \mintinline{js}|Symbol.customMatcher|, as opposed to \mintinline{js}|extractor|, a new well-known Symbol introduced as part of the proposal.
    \item The \mintinline{js}|extractor| method was an instance method. In the actual proposal the Extractor itself needs to have the method; i.e.~if the class itself should be usable as an Extractor, as opposed to instances of it, the method needs to be static.
\end{itemize}

A version of this example where these simplifications were undone, i.e.~one which follows the proposal exactly, can be seen in \zcref{lst:minimal-intro-example-fixed}\footnotemark{}.

\footnotetext{Note that a computed property name is necessesary to define a property name as a Symbol; see \zcref{sec:background-javascript-details}.}

\begin{listing}[htbp]
    \caption{Adjusted version of \zcref{lst:minimal-intro-example}, using the proposed method name and making it static.\label{lst:minimal-intro-example-fixed}}
    \begin{minted}[autogobble, highlightlines={9-11}]{js}
        class Point {
            #x; #y; // # prefix denotes private fields

            constructor(x, y) {
                this.#x = x;
                this.#y = y;
            }

            static [Symbol.customMatcher](subject) {
                return [subject.#x, subject.#y];
            }
        }

        const point = new Point(13, 37);
        const Point(x, y) = point; // calls Point[Symbol.customMatcher](point)
    \end{minted}
\end{listing}

This chapter goes into more detail on this proposals goals, syntax, and semantics. We begin by discussing the motivation behind the proposal in \zcref{sec:extractors-motivation}. Following this, we lay the groundwork for the implementation by elaborating on the core specification and semantics in \zcref{sec:extractors-core-specification-semantics}, laying out the functional requirements we will also later use in the evaluation phase. 

\section{Motivation\label{sec:extractors-motivation}}

There is an asymmetry between the mechanisms used to create data structures and those used to consume them. Developers have a multitude of language functionality for defining and constructing objects at their fingertips: classes with private fields, computed property names, factory functions, and more; however, the retrieval of this data is more limited. In particular there is currently no mechanism for executing user-defined logic during destructuring.

Consider the case where a point is given in the form of a plain JavaScript Object, and it should be destructured. This is possible with object destructuring.

\begin{simplecode}[js]
    const simplePoint = { x: 13, y: 37 };
    const { x, y } = simplePoint; // x === 13, y === 37
\end{simplecode}

But if points are given in the form of a class where e.g.~property values are private, destructuring is no longer possible

\begin{simplecode}[js]
    const point = new Point(13, 37);
    const { x, y } = point; // x, y === undefined
\end{simplecode}

The \mintinline{js}|Point| class could define a view method to keep its internals opaque but still allow access in this context, which can then be used for array destructuring.

\begin{simplecode}[js]
    const point = new Point(13, 37);
    // assume that this returns an array [x, y]
    const [x, y] = point.components();
\end{simplecode}

But this is not as powerful because it is not valid in all binding situations, unlike destructuring. For example, while the plain point object permitted destructuring in function parameters, this is not possible with a view method.

\begin{simplecode}[js]
    function f({ x, y }) { /* ... */ }
    function f(point.components()) { /* ... */ } // Error!
\end{simplecode}

The closest one could get with such a view method on the opaque \mintinline{js}|Point| class would either:

\begin{itemize}
    \item require polluting the function body with parameter-handling logic:
    \begin{simplecode}[js]
        function f(point) {
            const [x, y] = point.components();
            // ...
        }
    \end{simplecode}
    \item or, require misusing default parameters:
    \begin{simplecode}[js]
        function f(point, [x, y] = point.components()) {
            // ...
        }
        f(point); // Equivalent to f(point, undefined);
    \end{simplecode}
    This would work by accepting a second parameter, which callers should always leave undefined. In that case the default value for that parameter will always be evaluated, 
\end{itemize}

The proposal addresses this by introducing a mechanism to allow developers to define a special method on arbitrary objects, the result of which will be used for destructuring. With the addition of this method we can write

\begin{simplecode}[js]
    function f(Point(x, y)) { /* ... */ }
\end{simplecode}

which is just as expressive as destructuring of plain objects, but backed by user-defined logic. With this addition, the proposal allows for \enquote{destructuring-time}:
\begin{itemize}
    \item Validation, through the ability to verify that a subject (the object being destructured) conforms to arbitrary constraints before attempting extraction.
    \item Transformation, by giving the capacity to convert complex objects (e.g., a custom class) into primitive representations (usually the constructor arguments) seamlessly during binding or assignment.
    \item Encapsulation, enabling \enquote{views} into an object's state without exposing its internal storage layout, even in contexts where a regular method call would not be syntactically valid.
\end{itemize}

\section{Core Specification \& Semantics\label{sec:extractors-core-specification-semantics}}

Given the proposals' early stage in the TC39 process, details in the specification are still subject to change. For this reason, we will outline functional requirements that need to be fulfilled for an implementation of the proposal, rather than overly focusing on formal specification details.

\paragraph{Extractor patterns} First, we will consider the syntactic requirements of Extractors themselves. An Extractor pattern consists of a qualified name and a parenthesized list of elements. The following is a list of functional requirements in regard to this pattern syntax:

\begin{itemize}
    \item The Extractor name may be an identifier reference (optionally specifying \mintinline{text}|this| or \mintinline{text}|super|), a qualified name (like \mintinline{text}|Foo.Bar|) and contain array accesses.
    \begin{simplecode}[js]
        const Foo = [
            {
                Bar: {
                    [Symbol.customMatcher](subject) { /* ... */ },
                },
            },
        ];
        const this.Foo[0].Bar(y) = x;
    \end{simplecode}

    \item The parenthesized list may contain everything that an array destructuring pattern may also contain (specification: \mintinline{text}|BindingElementList| and \mintinline{text}|AssignmentElementList| respectively), which depends on whether it is a binding or assignment context as described in \zcref{sec:background-javascript-details}. In particular this means that in binding patterns the elements must be simple identifiers, while in assignment patterns they may e.g.~contain object or array accesses.
    \begin{simplecode}[js]
        // Binding
        const Point(x, y) = p;
        const Point(obj.x, arr[0]) = p; // Error!
        // Assignment
        Point(x, y) = p;
        Point(obj.x, arr[0]) = p;
    \end{simplecode}
    
    Importantly, this includes other, nested Extractors.
    \begin{simplecode}[js]
        const Line(Point(x1, y1), Point(x2, y2)) = line;
    \end{simplecode}
\end{itemize}

Next, we will consider requirements around where Extractor patterns are valid. Specifically, they are valid in all binding and assignment patterns (i.e.~in all places where e.g. array destructuring would also be valid). Nevertheless, also because these requirements are later used to ground the evaluation in \zcref{ch:evaluation}, we will formulate more explicit requirements around the integration into existing syntax.

\begin{itemize}
    \item Extractors must be integrated into the existing assignment and binding patterns such that statements such as
    \begin{simplecode}[js]
        const Foo(y) = x; // Binding
        Foo(y) = x; // Assignment
    \end{simplecode}
    are valid.

    \item They must also be valid as function parameters, as found in
    \begin{itemize}
        \item function declarations and expressions
        \begin{simplecode}[js]
            function draw(Point(x, y)) { /* ... */ }
            const f = function draw(Point(x, y)) { /* ... */ };
        \end{simplecode}
        \item arrow functions (whose parameters must be parenthesized to avoid ambiguity with function calls)
        \begin{simplecode}[js]
            const f = (Point(x, y)) => { /* ... */ };
        \end{simplecode}
        \item object methods; class constructors and setters
        \begin{simplecode}[js]
            class Shape {
                set center(Point(x, y)) { /* ... */ }
                constructor(Point(x, y)) { /* ... */ }
                draw(Point(x, y)) { /* ... */ }
            }
            const obj = { method(Point(x, y)) { ... } };
        \end{simplecode}
    \end{itemize}

    \item They must be valid in iteration statements
    \begin{simplecode}[js]
        for (const Point(x, y) of pointList) { /* ... */ }
        for await (const Point(x, y) of pointStream) { /* ... */ }

        for (const Key(k) in object) { /* ... */ }

        for (let Point(x, y) = start; /* ... */) { /* ... */ }
    \end{simplecode}

    \item They must be valid in \mintinline{js}|catch| clauses
    \begin{simplecode}[js]
        try { /* ... */ } catch (ErrorExtractor(error)) { /* ... */ }
    \end{simplecode}

    \item But they must not be valid outside of assignment (assignment expressions) and binding (variable declarations, function parameters, \ldots) patterns, where they would either be meaningless or invite confusion with regular function calls.
    
    \item Whereas in bindings the \mintinline{js}|x| and \mintinline{js}|y| of \mintinline{js}|const Point(x, y) = p;| must be new variable names, in assignments they may be anything that is valid on the left hand side of other assignments, including e.g.~member expressions (\mintinline{js}|Point(obj.x, this.arr[0]) = p;|);
    
    \item Extractors may appear inside destructuring patterns, but not as a rest element (last line in the following example).
    \begin{simplecode}[js]
        const [Point(x, y)] = listOfPoints;
        const { center: Point(x, y) } = shape;
        const [...Point(x, y)] = iterable; // Error
    \end{simplecode}
\end{itemize}

\paragraph{Extractor runtime semantics} Extractors behave analogously to array destructuring at runtime, both in binding and assignment contexts. The major difference is that array destructuring already starts with an iterable to be destructured (the subject), whereas Extractors need to first transform the subject into an iterable using the user-defined \mintinline{js}|[Symbol.customMatcher]| method.

This transformation is specified in the \mintinline{js}|InvokeCustomMatcherOrThrow(matcher, subject)| Abstract Operation\footnotemark{} (see Binding-Initialization runtime semantics in the specification), an overview of which is given in \zcref{fig:invoke-custom-matcher-or-throw-diagram}. In precise terms, where \mintinline{js}|matcher| is the Extractor, i.e. the \mintinline{js}|Foo| in \mintinline{js}|const Foo(y) = x;|, and \mintinline{js}|subject| the right hand side:

\begin{figure}[htbp]
    \centering
    \makebox[0pt]{\input{./invoke-custom-matcher-or-throw.pdf_tex}}
    \caption{Flowchart of the \mintinline{js}{InvokeCustomMatcherOrThrow} Abstract Operation, where \mintinline{js}{Foo} is an Extractor and \mintinline{js}{x} the subject.\label{fig:invoke-custom-matcher-or-throw-diagram}}
\end{figure}

\footnotetext{The proposal aligns itself to the Pattern Matching proposal in some ways that are not relevant if the Pattern Matching proposal is not also implemented. For example, \mintinline{text}|InvokeCustomMatcherOrThrow| in fact also takes a third argument, which is only relevant in a Pattern Matching context. While we implemented this to align with the specification, we leave it out here to avoid confusion.}

\begin{enumerate}
    \item If \mintinline{js}|matcher| is not an Object, throw a \mintinline{js}|TypeError|.
    \item Let \mintinline{js}|f| be \mintinline{js}|matcher[Symbol.customMatcher]|\footnotemark; if it is undefined throw a \mintinline{js}|TypeError|.
    \item Let \mintinline{js}|result| be \mintinline{js}|f.apply(matcher, subject)|; if it is not an Object, throw a \mintinline{js}|TypeError|.
    (The \mintinline{js}|apply| method of function instances calls the respective function with the first argument as its \mintinline{js}|this| value, and passes on the remaining arguments.)
    \item Return an iterator for \mintinline{js}|result|. (Since array destructuring also works with an iterable as the value to be destructured, this ensures consistency.)
\end{enumerate}

\footnotetext{Note that the bracket property accessor syntax is necessesary here; see \zcref{sec:background-javascript-details}.}

Given these semantics, an Extractor statement such as
\begin{simplecode}[js]
    const Foo(y, z) = x;
\end{simplecode}
may be equivalently reformulated to the array destructuring assignment
\begin{simplecode}[js]
    const [y, z] = InvokeCustomMatcherOrThrow(Foo, x);
\end{simplecode}
and further, leaving out edge case and error handling and \enquote{inlining} the call,
\begin{simplecode}[js]
    const [y, z] = Foo[Symbol.customMatcher].apply(Foo, x);
\end{simplecode}

But while this reformulation as a function is convenient as a demonstration of the runtime semantics, it should be noted that it cannot cover the entire syntax space of the Extractors proposal. For example, it cannot represent Extractors in binding contexts that are not variable declarations, such as function parameters or the \mintinline{js}{catch} clause.

% \paragraph{InvokeCustomMatcherOrThrow(matcher, subject)} Abstract Operation (see the Binding\-Initialization runtime semantics in the specification)\footnote{The proposal aligns itself to the Pattern Matching proposal in some ways that are not relevant if the Pattern Matching proposal is not also implemented. For example, \mintinline{text}|InvokeCustomMatcherOrThrow| in fact also takes a third argument, which is only relevant in a Pattern Matching context. While we implemented this to align with the specification, we leave it out here and in the binding/assignment semantics description to avoid confusion.}
% \begin{enumerate}
%     \item If \mintinline{js}|matcher| is not an Object, throw a \mintinline{js}|TypeError|
%     \item Let \mintinline{js}|f| be \mintinline{js}|matcher[Symbol.customMatcher]|; if it is undefined throw a \mintinline{js}|TypeError|
%     \item Let \mintinline{js}|result| be \mintinline{js}|f.apply(matcher, subject)|; if it is not an Object, throw a \mintinline{js}|TypeError|
%     \item Return an iterator for \mintinline{js}|result|
% \end{enumerate}

% \paragraph{Extractor binding semantics} (see the BindingInitialization runtime semantics in the specification)
% \begin{enumerate}
%     \item Let \mintinline{text}|extractor| be the expression that is covered by \mintinline{text}|ExtractorMemberExpression| (i.e., the \mintinline{js}|Foo| in \mintinline{js}|const Foo(y) = x;|)
%     \item Let \mintinline{text}|iterator| be \mintinline{text}|InvokeCustomMatcherOrThrow(extractor, value)| (where value is the right hand side---\mintinline{js}|x| in the previous example)
%     \item Using this \mintinline{text}|iterator|, perform the same binding steps that would happen when handling an array binding (c.f. \mintinline{text}|IteratorBindingInitialization| in the specification)
%     \item Close the \mintinline{text}|iterator| if necessary, and return the result from the previous step
% \end{enumerate}

% \paragraph{Extractor assignment semantics} (see the DestructuringAssignmentEvaluation runtime semantics in the specification) must behave analogously to the extractor binding pattern, adjusted for the general differences between binding and assignment semantics.

% \section{Prior Art\label{sec:extractors-prior-art}}

% %The conceptual influence behind the proposal is the concept of reversible constructors\footnotemark{}, originating from functional programming, which has also been called \enquote{Extraction} in the literature~\cite{matchingobjects07}. 

% \footnotetext{See \url{https://github.com/tc39/proposal-pattern-matching/issues/63} (accessed December 2025) for a detailed elaboration.}

% The proposal itself mentions the following language features as prior art:

% \begin{itemize}
%     \item \textbf{Scala} Extractor Objects
%     \item \textbf{C\#} Deconstruct
%     \item \textbf{F\#} Active Patterns
%     \item \textbf{Rust} Enums \& Pattern Matching
% \end{itemize}

% We will briefly describe each, and compare it to the proposed ECMAScript Extractors.

% \paragraph{Scala} Perhaps the most direct example of this pattern in other languages is Scala~\cite{matchingobjects07}, where Extractor Objects are objects with an \mintinline{scala}|unapply| method (see \zcref{lst:scala-extractor-object-example}), which is effectively equivalent in purpose and behavior to the method behind \mintinline{js}|Symbol.customMatcher|. From the Scala documentation: \enquote{Whereas the \mintinline{scala}|apply| method is like a constructor which takes arguments and creates an object, the \mintinline{scala}|unapply| method takes an object and tries to give back the arguments.}\footnote{\url{https://docs.scala-lang.org/tour/extractor-objects.html}, accessed December 2025}

% \begin{listing}[htbp]
%     \caption{Example of a Scala Extractor Object, showcasing the \mintinline{scala}{unapply} method and its usage.\label{lst:scala-extractor-object-example}}
%     \begin{minted}{Scala}
% case class Point(x: Int, y: Int)

% val p = Point(10, 20) // Construction
% val Point(x, y) = p // Extraction (calls Point.unapply(p))
%     \end{minted}
% \end{listing}

% The \mintinline{scala}|unapply| method may be refutable (may not succeed), but if it returns \mintinline{Scala}|None| or throws an exception, an exception is thrown on assignment.

% \paragraph{C\#} While both Scala and the ECMAScript proposal essentially define extractors as objects with a certain (generally static) method, C\# relies on a \mintinline{csharp}|Deconstruct| instance method on the object type to be deconstructed\footnote{\url{https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct}, accessed December 2025}.

% \begin{listing}[htbp]
%     \caption{Example of a C\# class with a \mintinline{csharp}{Deconstruct} method and its usage.\label{lst:csharp-deconstruct-example}}
%     \begin{minted}[highlightlines={13-18, 24}]{csharp}
% // (C#)
% public class Person
% {
%     public string FirstName { get; set; }
%     public string LastName { get; set; }

%     public Person(string fname, string lname)
%     {
%         FirstName = fname;
%         LastName = lname;
%     }

%     public void Deconstruct(out string fname, out string lname)
%     {
%         // Arbitrary logic in here 
%         fname = FirstName;
%         lname = LastName;
%     }
% }

% // Somewhere else:
% {
%     var p = new Person("John", "Smith")
%     var (fName, lName) = p;

%     // Compile time error since no matching Deconstructor is found
%     var (fName) = p;
% }
%     \end{minted}
% \end{listing}

% But while this has some benefits, like allowing it to omit the requirement of specifying which Extractor shall be used (as is always required in e.g.~Scala), it's more limiting than the alternative: Constructs like \zcref{lst:temporal-instant-extractor-example} in ECMAScript, where an Extractor operates on multiple different types that may not have a relation with each other or may even be primitives, are not possible with the instance-method approach. In this sense the ECMAScript implementation opts for increased flexibility and power over clearly enforced Constructor-Extractor symmetry, at the cost of slightly increased verbosity.

% \begin{listing}[htbp]
%     \caption{Example of an ECMAScript Extractor that operates on multiple different types, to contrast with the C\# approach in \zcref{lst:csharp-deconstruct-example}.\label{lst:temporal-instant-extractor-example}}
%     \begin{minted}{js}
% const InstantExtractor = {
%     [Symbol.customMatcher](value) {
%         if (value instanceof Temporal.Instant) {
%             return [value];
%         } else if (value instanceof Date) {
%             return [Temporal.Instant.fromEpochMilliseconds(+value)];
%         } else if (typeof value === 'string') {
%             return [Temporal.Instant.from(value)];
%         }
%     }
% };

% // Two different classes and a primitive are all used with the same Extractor
% const InstantExtractor(x) = Temporal.Instant.from(0);
% const InstantExtractor(y) = new Date(0);
% const InstantExtractor(z) = '1970-01-01T00:00:00Z';
%     \end{minted}
% \end{listing}

% \paragraph{F\#} While Scala (at least in terms of naming) focuses on the symmetry between its \mintinline{scala}|apply| and \mintinline{scala}|unapply| methods on Extractor Objects, F\# has a very generic concept of Active Patterns, which allow developers to effectively define named \enquote{views} on arbitrary data.

% \begin{listing}[htbp]
%     \caption{Example of a refutable F\# Active Pattern with two failure branches.\label{lst:fsharp-active-pattern-example}}
%     \begin{minted}{fsharp}
% let (|Point|_|) (input: string) =
%     let parts = input.Split(',')
%     match parts with
%     | [| x; y |] -> 
%         try Some(int x, int y) 
%         with _ -> None // Parse failed
%     | _ -> None // Format failed

% let rawData = "10,20"

% match rawData with
%     | Point (x, y) -> (* ...use x and y... *)
%     | _ -> (* Error *)
%     \end{minted}
% \end{listing}
% \zcref[S]{lst:fsharp-active-pattern-non-refutable-example} represents a very close functional equivalent to the proposed ECMAScript Extractors. But it's important to note that the above Active Pattern is refutable (as can be seen by the two failure branches), and that this would cause a compilation error if used in a binding without being handled. One way around this would be to introduce default values, as demonstrated in the following. Nevertheless, this doesn't directly map to the proposed behavior in ECMAScript, which is to throw a TypeError if the extractor doesn't succeed.

% \begin{listing}[htbp]
%     \caption{Example of a non-refutable F\# Active Pattern with no failure branches, contrasting with the refutable example in \zcref{lst:fsharp-active-pattern-example}.\label{lst:fsharp-active-pattern-non-refutable-example}}
%     \begin{minted}{fsharp}
% let (|Point|) (input: string) =
%     let parts = input.Split(',')
%     match parts with
%     | [| x; y |] -> 
%         match (Int32.TryParse x, Int32.TryParse y) with
%         | ((true, ix), (true, iy)) -> (ix, iy)
%         | _ -> (0, 0) // Parse failed
%     | _ -> (0, 0) // Format failed
%     \end{minted}
% \end{listing}

% \paragraph{Rust}
% Unlike the Active Patterns of F\# or the Extractors of Scala and this ECMAScript proposal, Rust's pattern matching is primarily structural rather than programmable. In Rust, one matches against the internal layout of \mintinline{rust}|struct|s or \mintinline{rust}|enum|s. There is no implicit execution of user logic during the binding phase (destructuring).

% \begin{listing}[htbp]
%     \caption{Rust pattern matching allows destructuring of Enums and Structs, but exclusively mirrors the data layout.\label{lst:rust-enum-example}}
%     \begin{minted}{rust}
% enum Message {
%     Quit,
%     Move { x: i32, y: i32 },
%     Write(String),
% }

% let msg = Message::Move { x: 10, y: 20 };

% match msg {
%     Message::Quit => println!("Quit"),
%     Message::Move { x, y } => println!("Move to {}, {}", x, y),
%     Message::Write(text) => println!("Text: {}", text),
% }
%     \end{minted}
% \end{listing}

% # reversible constructor paradigm & prior art

% - reversible constructor paradigm seems to be the conceptual influence behind the proposal (either way it certainly appears to prioritize following it)
%     - https://github.com/tc39/proposal-pattern-matching/issues/63 (is a discussion on the pattern mathing proposal but as far as i can tell the extractors one grew out of that)
%     - the syntax to deconstruct a value should be isomorphic to the syntax used to construct it; reduces cognitive load
%     - classic example, `const p = new Point(x, y)'; `const Point(x, y) = p;' (assuming Point is set up properly)
% - precedent/prior art/historical context
%     - discourse surrounding the proposal frequently references Scala's Extractor Objects (`unapply') as precedent
%         - https://docs.scala-lang.org/tour/extractor-objects.html
%         - but Scala is statically typed so doesn't need the instanceof etc. checks that `customMatcher' of this proposals need (a rough scala vs JS code snippet would be cool)
%     - others mentioned in README (it would be great to have roughly comparable code examples for each of these)
%         - C# 8.0 Deconstruct https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct
%         - F# Active Patterns https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns
%         - Rust Enums https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html
%         - Rust Pattern Matching https://doc.rust-lang.org/book/ch19-00-patterns.html
