\cleardoubleoddpage%
\chapter{Extractors\label{sec:extractors-proposal}}

\section{Motivation}

There is an asymmetry between the mechanism used to create data structures and those used to consume them. Developers have a multitude of language functionality for object construction at their fingertips: classes with private fields, computed property names, factory functions, \ldots, but retrieval of this data can often require stepping outside these declarative paradigms. While the destructuring syntax is a step towards this direction, it only allows for the extraction of data from Arrays and Objects based on their structural shapes---it doesn't support cases where transformation is required.

During development, this shortcoming may force developers to choose between encapsulation (private fields, specific constructors, \ldots) and development ergonomics (plain objects that are easy to destructure). The proposal addresses this by introducing a pattern that can execute user-defined logic during the binding phase. This logic is attached to objects through a new well-known property, \mintinline{js}{Symbol.customMatcher}, which can then be used for this purpose.

\begin{minted}[highlightlines={9-11, 15}]{js}
class Point {
    #x;
    #y;
    constructor(x, y) {
        this.#x = x;
        this.#y = y;
    }

    static [Symbol.customMatcher](subject) {
        return #x in subject ? [subject.#x, subject.#y] : false;
    }
}

const p = new Point(1, 2); // Construction
const Point(x, y) = p; // Extraction (calls Point[Symbol.customMatcher](p))
x; // 1
y; // 2
\end{minted}

(As will be outlined later, another motivation is to improve the ergonomics of \emph{Pattern Matching}, another proposal, see \zcref{sec:ecosystem-and-related-proposals}.)

With this addition, the proposal augments the existing binding and assignment patterns to allow for:
\begin{itemize}
    \item Validation, through the ability to verify that a subject conforms to a specific type or constraint before attempting extraction.
    \item Transformation, by giving the capacity to convert complex objects (e.g., a custom Class) into primitive repressentations (usually the constructor arguments) seamlessly during the assignment.
    \item Encapsulation, enabling \enquote{views} into an object's state without exposing its internal storage layout.
\end{itemize}

% - currently there is asymmetry between the mechanisms used to create data structures and those used to consume them
%     - lots of language functionality related to object construction: 
%     - but retrieval of this data can often require stepping outside this (declarative) paradigm
% - destructuring assignment (ES6) allows for extraction of data from Arrays and Objects based on their structural shape only, it doesn't support cases where transformation is required
%     - e.g. constructing a `Temporal.Instant` from a string is easy (concise, declarative) but extracting its epoch milliseconds within a destructuring flow is impossible without imperative if/else blocks or auxiliary constructs
%         - https://github.com/tc39/proposal-extractors/issues/15#issuecomment-2037675151 for rough emulation with auxiliary variables (but not exactly relevant)
%         - example code with/without extractors
%     - can force a choice between encapsulation (private fields, specific constructors, ...) and development ergonomics (plain objects that are easy to destructure)
%     - proposal addresses this by introducing a pattern that can execute user-defined logic during the binding phase, allowing for
%         - data validation: The ability to verify that a subject conforms to a specific type or constraint before attempting extraction.
%         - transformation: The capacity to convert complex objects (e.g., a `Date' object) into primitive representations (e.g., a string) seamlessly during the assignment.
%         - encapsulation: The enablement of "views" into an object's state without exposing its implementation details (internal storage layout).
% -> show a code sample here (maybe inspired by the README one, but that one doesn't really illustrate it that well)

\section{Reversible Constructor Paradigm \& Prior Art}

While this wasn't always the case, for the current iteration of the Extractors proposal, the \emph{Reversible Constructor Paradigm} is a major influence\footnote{For a discussion that documents this, see \url{https://github.com/tc39/proposal-pattern-matching/issues/63}, accessed 20/11/2025 (note that this links to the \emph{Pattern Matching} proposal, out of which the \emph{Extractors} proposal grew)}. This principle requires that the syntax used to deconstruct a value should be isomorphic to the syntax used to construct it. This symmetry reduces cognitive load by allowing developers to use their knowledge of an Object's construction interface to make a reasonable guess at its destruction interface.

Somewhat more formally, let $C$ be a constructor and $E$ be an extractor. If $x = C(\alpha)$ then the pattern $E(\alpha) = x$ must hold true. It should be noted that the proposal merely allows these conditions to hold, it is of course up to developers to use the functionality as they see fit.

\subsection{Extractors as Seen in Other Languages}

\paragraph{Scala} Perhaps the most direct example of this pattern in other languages is Scala, where \emph{extractor objects} are objects with an \mintinline{Scala}|unapply| method, whch is effectively equivalent in purpose and behavior to the method behind \mintinline{JS}|Symbol.customMatcher|. From the Scala documentation: \enquote{Whereas the \mintinline{Scala}|apply| method is like a constructor which takes arguments and creates an object, the \mintinline{Scala}|unapply| takes an object and tries to give back the arguments.}\footnote{\url{https://docs.scala-lang.org/tour/extractor-objects.html}, accessed 20/11/2025}

\begin{minted}{Scala}
// (Scala; TODO: expand to not-quite-as-trivial example to showcase power)
case class Point(x: Int, y: Int)

val p = Point(10, 20) // Construction
val Point(x, y) = p // Extraction (calls Point.unapply(p))
\end{minted}

The \mintinline{Scala}|unapply| method may be \emph{refutable}, but if it returns \mintinline{Scala}|None| or throws an exception, an exception is thrown on assignment.

\paragraph{C\#} While both Scala and the ECMAScript proposal essentially define extractors as objects with a certain (static) method, C\# relies on a \mintinline{CSharp}|Deconstruct| \emph{instance} method on the object type to be deconstructed\footnote{\url{https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct}, accessed 20/11/2025}.

\begin{minted}[highlightlines={13-18, 22}]{CSharp}
// (C#)
public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }

    public Person(string fname, string lname)
    {
        FirstName = fname;
        LastName = lname;
    }

    public void Deconstruct(out string fname, out string lname)
    {
        // Arbitrary logic in here, 
        fname = FirstName;
        lname = LastName;
    }
}

// ... somewhere else ...
var p = new Person("John", "Smith")
var (fName, lName) = p;
\end{minted}

(It's a compile-time error to not have a matching \mintinline{CSharp}|Deconstruct| for a given deconstruct assignment operation.)

But while this has some benefits, like allowing it to omit the requirement of specifying which Extractor shall be used (as is always required in e.g.~the ECMAScript proposal), it's more limiting than the alternative: Constructs like the following in ECMAScript, where an Extractor operates on multiple different types that may not have a relation with each other or may even be primitives, are not possible with the instance-method approach. In this sense the ECMAScript implementation opts for increased flexibility and power over clearly enforced Constructor-Extractor symmetry, at the cost of slightly increased verbosity.

\begin{minted}{JS}
const InstantExtractor = {
    [Symbol.customMatcher](value) {
        if (value instanceof Temporal.Instant) {
            return [value];
        } else if (value instanceof Date) {
            return [Temporal.Instant.fromEpochMilliseconds(+value)];
        } else if (typeof value === "string") {
            return [Temporal.Instant.from(value)];
        }
    }
};

// Two different classes and a primitive are all used with the same Extractor
const InstantExtractor(x) = Temporal.Instant.from(0);
const InstantExtractor(y) = new Date(0);
const InstantExtractor(z) = "1970-01-01T00:00:00Z";
\end{minted}

\paragraph{F\#} Much like Scala and ECMAScript, F\# 

\paragraph{Rust} TODO


% # reversible constructor paradigm & prior art

% - reversible constructor paradigm seems to be the conceptual influence behind the proposal (either way it certainly appears to prioritize following it)
%     - https://github.com/tc39/proposal-pattern-matching/issues/63 (is a discussion on the pattern mathing proposal but as far as i can tell the extractors one grew out of that)
%     - the syntax to deconstruct a value should be isomorphic to the syntax used to construct it; reduces cognitive load
%     - classic example, `const p = new Point(x, y)'; `const Point(x, y) = p;' (assuming Point is set up properly)
% - precedent/prior art/historical context
%     - discourse surrounding the proposal frequently references Scala's Extractor Objects (`unapply') as precedent
%         - https://docs.scala-lang.org/tour/extractor-objects.html
%         - but Scala is statically typed so doesn't need the instanceof etc. checks that `customMatcher' of this proposals need (a rough scala vs JS code snippet would be cool)
%     - others mentioned in README (it would be great to have roughly comparable code examples for each of these)
%         - C# 8.0 Deconstruct https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct
%         - F# Active Patterns https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns
%         - Rust Enums https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html
%         - Rust Pattern Matching https://doc.rust-lang.org/book/ch19-00-patterns.html

\section{Ecosystem \& Related Proposals\label{sec:ecosystem-and-related-proposals}}













% \begin{comment}
% # motivation

% # ecosystem & related proposals (working title)

% - pattern matching!
%     - extractors are effectively required for the pattern matching proposal and were split out of it
%         - `match' expressions would work without them, but the power of pattern matching in languages like Rust or Elixir comes from matching against data types and variants (= Extractors use case)
%     - code example to demonstrate this
% - regex (assuming RegExp.prototype[Symbol.customMatcher] gets an appropriate built-in definition, see tests)
%     - const /(?<year>\d{4})-(?<month>\d{2})/({ groups: { year, month } }) = "2024-01";
% - temporal would also be a natural fit (code example!)
% - discard bindings (proposal, stage 2, https://github.com/tc39/proposal-discard-binding); similar to _ in Scala and Rust
%     - it's likely that developers will end up in situations where extractors return more values than are needed in a particular situation, `const Point(_unused, y) = p; // Linter error: '_unused' is defined but never used'
%     - proposal introduces `void' keyword as a binding pattern to explicitly ignore values, `const Point(void, y) = p; // Explicit discard'
% - `Map' destructuring
%     - from a performance point of view, `Map's are generally preferable to plain objects
%     - one reason they aren't adopted more is their comparatively poor ergonomics, e.g. one can do `const { a, b } = { a: 1, b: 2 }' but not `const { a, b } = new Map([ [a, 1], [a, 2] ])'
%     - with an extractor that would be possible (code example! add test)
%     - (similar functionality was historically proposed as specific syntax for `Map's in https://www.proposals.es/proposals/Tagged%20Collection%20Literals, the Extractors proposal can be viewed as a generalization of that)
% - analogous to `Map', also for `Set'

% # core specification & semantics

% ## grammar augmentation

% note that graaljs doesn't have a 1-1 implementation of spec grammar -> the spec grammar needs to be considered to understand how things should behave, but the actual implementation will not necessarily use the same constructions to reach that.

% `BindingPattern' is modified to include ExtractorBindingPattern:

% ```
% ExtractorBindingPattern :
%     ExtractorMemberExpression ( Elision_opt BindingRestElement_opt )
%     ExtractorMemberExpression ( BindingElementList )
%     ExtractorMemberExpression ( BindingElementList , Elision_opt BindingRestElement_opt )
% '''
% (which is identical to how ArrayBindingPattern is defined, except with `(' instead of `[')

% with the following semantics (simplified: leaving out details only relevant in the context of the spec and as-of-yet unused functionality)
%     1. let `extractor' be the left hand side expression that is covered by ExtractorMemberExpression (e.g., the `Point' in `... Point(x, y) = ...')
%     2. let `iterator' be `InvokeCustomMatcherOrThrow(extractor, value)' (where value is the right hand side)
%     3. perform IteratorBindingInitialization of this ExtractorBindingPattern (this is defined to behave exactly as array binding) and let the result be `result'
%     4. return `result'

% ExtractorAssignmentPattern also follows ArrayAssignmentPattern with behavior analogous to ExtractorBindingPattern

% InvokeCustomMatcherOrThrow(matcher, subject) is an abstract operation (https://tc39.es/ecma262/#sec-abstract-operations, see background chap):
%     1. if matcher is not an object, throw a TypeError
%     2. let f be matcher[Symbol.customMatcher]
%     3. if f is undefined, throw a TypeError
%     4. let result be f.apply(matcher, subject)
%     5. if result is not an Object, throw a TypeError
%     6. return iterator for result

% - on parentheses vs. other options (to explain why this is even a question: parentheses are a clear choice when symmetry with constructors is desirable, but one could also reasonably consider symmetry with array and object destructuring to be desirable)
%     - can't use '[' because there would be a collision with ElementAccessExpression (while `const Point[x] = p' would be fine, `Point[x] = p' is already valid and interpreted as assigning `p' to the property `x' of `Point')
%     - historically (https://github.com/tc39/proposal-extractors/issues/10) there were "Array Extractors" using `(' and "Object Extractors" (`const Point{ x, y } = p;') using `{' but it was decided to drop Object Extractors since (1) `identifier {' would reserve a lot of syntax space and (2) object extraction can still be achieved with array extraction (`Point({ x, y })')
% - LHS restrictions
%     - extractors are only valid in BindingPattern (var/let/const declarations, function parameters) and AssignmentPattern (assignment expressions)
%     - in particular not as standalone expressions, to prevent ambiguity with function calls
% - runtime performance concerns
%     - iterators have big overhead compared to just array-like (https://github.com/tc39/proposal-pattern-matching/issues/315)
%     - the `Symbol.customMatcher' is still a dynamic method call
% \end{comment}
