\cleardoubleoddpage%
\chapter{Implementation}
\label{ch:implementation}

This chapter details the technical realization of the Extractors proposal within the GraalJS engine. The implementation touches multiple layers of the engine's architecture: the parser, the AST translator, and the runtime execution nodes. We first describe the parser modifications required to disambiguate Extractors from function calls in \zcref{sec:implementation-parser}. Next, we examine the translation process that converts the Parser AST nodes into executable Truffle nodes in \zcref{sec:implementation-graaljstranslator}. Finally, we cover the runtime behavior, specifically the \mintinline{js}|InvokeCustomMatcherOrThrow| operation that drives the extraction logic in \zcref{sec:implementation-invokecustommatcherorthrow}.

\section{Parser}
\label{sec:implementation-parser}

The primary challenge in parsing Extractors is syntactic ambiguity. To a parser, an Extractor pattern such as \mintinline{js}|Foo(a, b)| is syntactically identical to a function call. In standard ECMAScript, a function call is not a valid Left-Hand Side (LHS) expression for an assignment (e.g., \mintinline{js}|f() = x| throws a \mintinline{js}|ReferenceError|). With this proposal, however, such expressions become valid assignment and binding targets. Notably, we chose not to introduce a new Parser AST Node for Extractors, but to re-use the existing \mintinline{js}|CallNode| since there is no ambiguity---an Extractor will never appear in a place where a function call would have also been valid.

\paragraph{Assignment} To accommodate support for statements such as \mintinline{js}|Foo(a, b, c) = x| (where \mintinline{js}|Foo| is an Extractor and \mintinline{js}|a|, \mintinline{js}|b| and \mintinline{js}|c| are existing identifiers), we need to modify the \mintinline{js}|verifyAssignment(lhs, op, rhs)| method in the Parser. This method is responsible for validating expressions of the form \mintinline{text}|{lhs} {op} {rhs}|. When the Parser encounters a \mintinline{js}|CallNode| as the LHS of an assignment, it no longer immediately rejects it. Instead, if the Extractors feature flag is enabled, the Parser treats the call tentatively as a destructuring pattern; i.e.~if it encounters an Extractor assignment statement as above, these modifications make it treat it analogously to
\begin{simplecode}[js]
    [a, b, c] = /* something */
\end{simplecode}
The parsing and validation of destructring assignments is delegated to \mintinline{js}|verifyDestructuringAssignmentPattern|, which traverses the LHS node and its descendants. Previously it would  The visitor logic was updated to handle \mintinline{js}|CallNode| instances as follows:
\begin{itemize}
    \item When the visitor encounters a \mintinline{js}|CallNode| in a destructuring context, it treats it analogously to an \mintinline{js}|ArrayNode|. 
    \item Accordingly, the arguments of the call (e.g., \mintinline{js}|a, b| in \mintinline{js}|Foo(a, b)|) are validated as if they were elements of an array destructuring pattern.
    \item This re-use of logic matches the spirit of the specification and ensures that nested patterns (e.g., \mintinline{js}|Foo(Bar(x))|) are supported automatically via recursion.
\end{itemize}

\paragraph{Binding} Similar modifications were required for variable declarations (e.g., \mintinline{js}|const Foo(x) = y;|). Previously, \mintinline{js}|variableDeclarationList| parsed the LHS of a binding assignment using \mintinline{text}|bindingIdentifierOrPattern|, which expected either a simple identifier or a standard destructuring pattern (an array or object). We loosened this constraint to parse the broader \mintinline{text}|leftHandSideExpression|. This aligns the parsing logic with \mintinline{text}|assignmentExpression|, allowing \mintinline{js}|CallNode|s to be captured and subsequently validated by \mintinline{js}|verifyAssignment| (i.e.~the same logic as discussed in Assignment).

While this catches the most basic case of bindings (explicit variable declarations), other forms exist as mentioned in \zcref{sec:extractors-core-specification-semantics}. In particular, to support Extractors in other places such as function parameters or the \mintinline{js}|catch| block, we had to implement lookahead checks\footnote{The parser generally looks only at the current token in the input, consuming it in the process. But disambiguating certain language constructs may necessitate inspecting more of the (future) input without consuming it.}. To give a singular example, to parse function parameters there was previously a check similar to the following.
\begin{simplecode}[java]
    if (type == IDENT) {
        // parse an identifier as the parameter
        // e.g. f(a, b, c)
    } else {
        // attempt to parse a binding pattern, which may start either with [ or {
        // e.g. f({ a, b }, [c])
    }
\end{simplecode}
But now we needed to support binding patterns that start with an identifier, so a lookahead was implemented to differentiate between the start of a binding identifier and a binding pattern in this context, replacing the simple next token check.
\begin{simplecode}[java]
    private boolean lookaheadIsSimpleFormalParameter() {
        if (!isBindingIdentifier()) {
            return false;
        }

        return lookaheadFindTokenSkippingComments(COMMARIGHT) || lookaheadFindTokenSkippingComments(RPAREN) || lookaheadFindTokenSkippingComments(ASSIGN);
    }
\end{simplecode}

\paragraph{Feature Flag} Given the experimental nature of the proposal and this implementation of it, we implemented the support for Extractors as an opt-in feature at the parser level, disabling the new behavior by default. This ensures that the new syntax does not interfere with parsing in default environments that do not expect it.

The configuration is exposed as a \mintinline{java}|JSContextOption|, joining the suite of over 100 existing engine options. This design allows users to change it just as they would any other option, e.g.~when embedded using GraalVM's Polyglot API:
\begin{simplecode}[js]
Context context = Context.newBuilder("js")
    .option("js.extractors", "true")
    .build();
context.eval("js", "/* ... */");
\end{simplecode}

Internally, the propagation of this option follows the standard engine architecture:
\begin{enumerate}
    \item The option is defined in \mintinline{java}|JSContextOptions|.
    \item From there it is passed through \mintinline{java}|JSLanguageObjects| into \mintinline{java}|JSParserOptions|.
    \item Finally, it is consumed by the \mintinline{java}|GraalJSParserHelper| to construct a \mintinline{java}|ScriptEnvironment|.
\end{enumerate}

This \mintinline{java}|ScriptEnvironment| then serves as the immutable source of truth for the parser's capabilities, also including e.g.~such options as allowing top-level \mintinline{js}|await| or dictating whether or not strict mode is enabled. The flag is then used as a strict guard: modifications that permit previously invalid syntax---e.g.~allowing \mintinline{js}|CallNode|s in the LHS---are ignored unless this flag is explicitly set.

\section{GraalJSTranslator}
\label{sec:implementation-graaljstranslator}

Once the AST is parsed and verified as in \zcref{sec:implementation-parser}, the \mintinline{js}|GraalJSTranslator| converts it into a tree of executable Truffle nodes. The core logic for Extractors resides in the transformation of assignment nodes. To that end we modified \mintinline{js}|transformAssignmentImpl| to detect when the assignment target is a \mintinline{js}|CallNode|. In such cases, it delegates to a new method, \mintinline{js}|transformAssignmentExtractor|, which generates the necessary runtime nodes to perform the extraction.

The transformation process involves three distinct steps:
\begin{enumerate}
    \item Resolution: The \enquote{function} part of the call (the Extractor) is transformed. (If it is a property access (e.g., \mintinline{js}|A.B(x)|), the receiver is preserved to ensure correct \mintinline{js}|this| binding.)
    \item Invocation: A new node, \mintinline{js}|InvokeCustomMatcherOrThrowNode| (detailed in \zcref{sec:implementation-invokecustommatcherorthrow}), is created. This node is responsible for calling \mintinline{js}|Symbol.customMatcher| at runtime.
    \item Destructuring: The arguments of the extractor are treated as a standard array destructuring assignment, applied to the result of the custom matcher.
\end{enumerate}

The implementation of this transformation is shown in \zcref{lst:transform-assignment-extractor}. Note the use of a temporary variable (\mintinline{js}|valueTempVar|) to hold the RHS value. This ensures that the assignment expression evaluates to the assigned value (preserving the invariant \mintinline{js}|(Foo(x) = y) === y|), regardless of the extractor's logic, analogous to assignment behavior in other cases (e.g.~\mintinline{js}|[x] = [1]| evaluates to \mintinline{js}|[1]|). Another temporary variable (\mintinline{js}|assignedValueTempVar|) is used to prevent evaluating \mintinline{js}|assignedValue| more than once, which might have side effects (see the bug found in \zcref{sec:evaluation-selected-found-defects}).

\begin{listing}[htbp]
    \caption{Transformation logic converting an assignment consisting of a \mintinline{js}{CallNode} on the LHS into effectively the same nodes that would result from a destructuring array assignment for the desugaring of Extractors: \mintinline{js}{[...params] = Extractor[Symbol.customMatcher](instance)}.\label{lst:transform-assignment-extractor}}
\begin{minted}{java}
    private JavaScriptNode transformAssignmentExtractor(CallNode fakeCallNode, JavaScriptNode assignedValue, boolean initializationAssignment) {
        final var functionExpr = fakeCallNode.getFunction();
        final var function = transform(functionExpr);

        var receiver = /* either function or base of access node */;

        VarRef assignedValueTempVar = environment.createTempVar();
        JavaScriptNode storeAssignedValue = assignedValueTempVar.createWriteNode(assignedValue);
        JavaScriptNode readAssignedValue = assignedValueTempVar.createReadNode();

        final var invokeCustomMatcherOrThrowNode = factory.createInvokeCustomMatcherOrThrow(context, function, readAssignedValue, receiver, environment.isStrictMode());

        final var args = fakeCallNode.getArgs();
        VarRef valueTempVar = environment.createTempVar();
        return createBlock(
                storeAssignedValue,
                this.transformDestructuringArrayAssignment(args, invokeCustomMatcherOrThrowNode, valueTempVar, initializationAssignment),
                valueTempVar.createWriteNode(assignedValueTempVar.createReadNode())
        );
    }
    \end{minted}
\end{listing}

\section{InvokeCustomMatcherOrThrow}
\label{sec:implementation-invokecustommatcherorthrow}

The runtime behavior is encapsulated in the \mintinline{js}|InvokeCustomMatcherOrThrow| Node, which is constructed for assignments involving Extractors as seen in \zcref{sec:implementation-graaljstranslator}. This Node implements the specific algorithm defined in the proposal for retrieving and executing the custom matcher. The core execution flow is detailed in \zcref{lst:invoke-custom-matcher}.

It should be noted that this implementation contains a deviation from the specification\footnote{See e.g.~discussion in issue \url{https://github.com/tc39/proposal-extractors/issues/34} (accessed December 2025)} concerning the behavior when the LHS does not have a \mintinline{js}|Symbol.customMatcher| method. In standard ECMAScript, assigning to a function call (\mintinline{js}|f() = x|) results in a \mintinline{js}|ReferenceError|. However, the Extractors proposal makes this syntax valid, creating a potential ambiguity around whether \mintinline{js}|f() = x| would in this case be a failed extractor usage or an invalid assignment.

This is particularly relevant since, in non-strict mode, the expected behavior is to throw an error after performing the function call. As suggested in the linked discussion, our implementation thus behaves differently depending on mode:
\begin{enumerate}
    \item In strict mode, we follow the specification and throw a \mintinline{js}|ReferenceError|.
    \item In non-strict mode, we execute the call as a standard function first. This ensures that any side effects still occur, before finally throwing an error.
\end{enumerate}

\begin{listing}[htbp]
    \caption{Implementation of the \mintinline{js}{InvokeCustomMatcherOrThrow} abstract operation.\label{lst:invoke-custom-matcher}}
    \begin{minted}{java}
        protected final IteratorRecord invokeCustomMatcherOrThrow(/* ... */) {
            // 1. If matcher is not an Object, throw a TypeError exception.
            if (!isObjectNode.executeBoolean(matcher)) {
                errorBranchProfile.enter(this);
                throw Errors.createTypeErrorNotAnObject(matcher);
            }
            
            // 2. Let f be ? GetMethod(matcher, @@customMatcher).
            final var f = this.getCustomMatcherNode.executeWithTarget(matcher);
            
            // 3. If f is undefined, throw a TypeError exception.
            if (f == Undefined.instance) {
                // Simplified: see note on specification deviation
                errorBranchProfile.enter(this);
                throw Errors.createTypeError("matcher does not have Symbol.customMatcher method");
            }
            
            // 4. Let result be ? Call(f, matcher, « subject, "list", receiver »).
            final var result = this.callNode.executeCall(JSArguments.create(matcher, f, subject, "list", receiver));
            
            // 5. If result is not an Object, throw a TypeError exception.
            if (!isObjectNode.executeBoolean(result)) {
                errorBranchProfile.enter(this);
                throw Errors.createTypeErrorInvalidCustomMatcherReturnValue(result, this);
            }
            
            // 6. Let iteratorRecord be ? GetIterator(result, sync). & 7. Return iteratorRecord.
            return getIteratorNode.execute(this, result);
        }
    \end{minted}
\end{listing}
